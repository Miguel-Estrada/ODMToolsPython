"""Subclass of frmDataFilters, which is generated by wxFormBuilder."""

from datetime import datetime

import wx
from wx.lib.pubsub import pub as Publisher


# # Enable logging
import logging
from odmtools.common.logger import LoggerTool
from odmtools.view import clsDataFilters

tool = LoggerTool()
logger = tool.setupLogger(__name__, __name__ + '.log', 'w', logging.DEBUG)
# #




# Implementing frmDataFilters
class frmDataFilter(clsDataFilters.clsDataFilters):
    def __init__(self, parent, series):
        self.is_applied = False
        self.recordService = series
        clsDataFilters.clsDataFilters.__init__(self, parent)

        self.setDates()


    def onCheckbox(self, event):
        self.recordService.toggle_filter_previous()


    def onSetFocus(self, event):
        logger.debug("event id : %s" % repr(event.Id))

        # DateRange
        if event.Id in (self.dpAfter.Id, self.dpBefore.Id, self.tpBefore.Id, self.tpAfter.Id, self.sbAfter.Id, self.sbBefore.Id):
            self.rbDate.SetValue(True)
        #Data Gaps
        elif event.Id in ( self.txtGapsVal.Id, self.cbGapTime.Id):
            self.rbDataGaps.SetValue(True)
        #Value Threshold
        elif event.Id in (self.txtThreshValLT.Id, self.txtThreshValGT.Id ):
            self.rbThreshold.SetValue(True)
        #value change threshold
        elif event.Id in(self.txtVChangeLT.Id, self.txtVChangeGT.Id) :
            self.rbVChangeThresh.SetValue(True)

        event.Skip()


    def onBtnClearButton(self, event):
        self.setDates()
        self.txtThreshValGT.Clear()
        self.txtThreshValLT.Clear()
        self.txtGapsVal.Clear()
        self.cbGapTime.SetStringSelection("second")
        self.txtVChangeThresh.Clear()
        self.recordService.reset_filter()

        #Publisher.sendMessage(("changePlotSelection"), sellist=self.recordService.get_filter_list())
        event.Skip()


    def onBtnOKButton(self, event):

        self.recordService.toggle_filter_previous(self.chkToggleFilterSelection.Value)

        if not self.is_applied:
            self.onBtnApplyButton(event)
        event.Skip()
        self.Close()


    def onBtnCancelButton(self, event):
        event.Skip()
        self.Close()


    def onBtnApplyButton(self, event):
        self.is_applied = True
        if self.rbThreshold.GetValue():
            if self.txtThreshValGT.GetValue():
                self.recordService.filter_value(float(self.txtThreshValGT.GetValue()), '>')
            if self.txtThreshValLT.GetValue():
                self.recordService.filter_value(float(self.txtThreshValLT.GetValue()), '<')

        elif self.rbDataGaps.GetValue():
            if self.txtGapsVal.GetValue():
                self.recordService.data_gaps(float(self.txtGapsVal.GetValue()), self.cbGapTime.GetValue())

        elif self.rbDate.GetValue():
            dateAfter = self.dpAfter.GetValue()
            timeAfter = self.tpAfter.GetValue(as_wxDateTime=True)
            dateBefore = self.dpBefore.GetValue()
            timeBefore = self.tpBefore.GetValue(as_wxDateTime=True)


            #convert to datetime.datetime from wxdatetime time
            dtDateAfter=_wxdate2pydate(dateAfter, timeAfter)
            dtDateBefore= _wxdate2pydate(dateBefore, timeBefore)
            #dtDateAfter = datetime(int(dateAfter.Year), int(dateAfter.Month)+1, int(dateAfter.Day), int(timeAfter.Hour), int(timeAfter.Minute), timeAfter.Second)
            #dtDateBefore = datetime(int(dateBefore.Year), int(dateBefore.Month)+1, int(dateBefore.Day), int(timeBefore.Hour), int(timeBefore.Minute), int(timeBefore.Second))
            self.recordService.filter_date(dtDateBefore, dtDateAfter)

        elif self.rbVChangeThresh.GetValue():
           if self.txtVChangeGT.GetValue():
                self.recordService.value_change_threshold(float(self.txtVChangeGT.GetValue()), '>')
           elif self.txtVChangeLT.GetValue():
                self.recordService.value_change_threshold(float(self.txtVChangeLT.GetValue()), '<')

        #Publisher.sendMessage("changeSelection", sellist=self.recordService.get_filter_list(), datetime_list=[])
        #Publisher.sendMessage("changeTableSelection", sellist=self.recordService.get_filter_list(), datetime_list=[])
        event.Skip()


    def setDates(self):
        dateAfter = self.recordService.get_series_points()[0][2]
        dateBefore = self.recordService.get_series_points()[-1][2]

        # logger.debug("dateAfter: ", repr(dateAfter.day), " + ", repr(dateAfter.month), " + ", repr(dateAfter.year))
        # logger.debug("dateBefore: ", repr(dateBefore.day), " + ", repr(dateBefore.month), " + ", repr(dateBefore.year))

        #subtract one from the month because DMY counts from 0 where dateAfter counts months from 1
        #formattedDateAfter = wx.DateTimeFromDMY(day=int(dateAfter.day), month=int(dateAfter.month)-1,
                                                #year=int(dateAfter.year))
        #add an extra day so you can see the full extent of the data(until midnight)
        #formattedDateBefore = wx.DateTimeFromDMY(day=int(dateBefore.day), month=int(dateBefore.month)-1,
                                                 #year=int(dateBefore.year))

        formattedDateAfter = _pydate2wxdate(dateAfter)
        formattedDateBefore =_pydate2wxdate(dateBefore)

        self.dpAfter.SetRange(formattedDateAfter, formattedDateBefore)
        self.dpBefore.SetRange(formattedDateAfter, formattedDateBefore)
        self.dpAfter.SetValue(formattedDateAfter)
        self.tpBefore.SetValue(wx.DateTimeFromHMS(hour=23, minute=59, second=59))
        self.dpBefore.SetValue(formattedDateBefore)



def _pydate2wxdate(date):
     import datetime
     assert isinstance(date, (datetime.datetime, datetime.date))
     tt = date.timetuple()
     dmy = (tt[2], tt[1]-1, tt[0])
     return wx.DateTimeFromDMY(*dmy)


def _wxdate2pydate(date, time):
     import datetime
     assert isinstance(date, wx.DateTime)
     assert isinstance(time, wx.DateTime)
     if date.IsValid() and time.IsValid():
         ymd = map(int, date.FormatISODate().split('-'))
         hms = map(int, time.FormatISOTime().split(':'))
         return datetime.datetime(*(ymd+hms))
     else:
         return None

